<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog CompVis</title>

    <link rel="stylesheet" href="estilo.css">
</head>
<body>

    <header>
        <h1>Blog para aula de computação visual</h1>

        <p>Gabriel Kury Fonseca | TIA 3215384 | RA 10390103</p>

        <nav id="indice">
            <h2>Índice de aulas</h2>
            
            <ol>
                <li><a href="#atvd1">Atividade 1 (O que é Computação Visual?)</a></li>
                <li><a href="#atvd2">Atividade 2 (Aplicações de Computação Visual)</a></li>
                <li><a href="#atvd3">Atividade 3 (Formatos de imagem)</a></li>
                <li><a href="#atvd4">Atividade 4 (GitHub Classroom - AP1)</a></li>
                <li><a href="#atvd5">Atividade 5 (GitHub Classroom - AP2)</a></li>
                <li><a href="#atvd6">Atividade 6 (GitHub Classroom - AP3)</a></li>
                <li><a href="#atvd7">Atividade 7 (GitHub Classroom - AP4)</a></li>
                <li><a href="#atvd8">Atividade 8 (APIs gráficas)</a></li>
            </ol>
        </nav>
    </header>

    <main>
        <section id="atvd1">
            <h2 class="tituloAtvd">Atividade 1 (O que é Computação Visual?)</h2>
            <a href="#indice">Índice de atividades</a>

            <p class="resposta">Ao ler o nome da disciplina Computação Visual pensei que a matéria seria sobre como a imagem é gerada e renderizada pelos computadores, sendo que ao final da matéria teria noção de como gerar e manipular imagens com linhas de código, sem auxílio de ferramentas além do compilador.</p>
        </section>
        

        <section id="atvd2">
            <h2 class="tituloAtvd">Atividade 2 (Aplicações de Computação Visual)</h2>
            <a href="#indice">Índice de atividades</a>

            <h3>Computação Gráfica</h3>
            <p class="resposta">A Computação Gráfica (CG) é uma área da Ciência da Computação que se dedica
                ao estudo e desenvolvimento de técnicas e algoritmos para a geração (síntese) de imagens. Esta área está presente em diversos ramos, como no projeto de modelo de automoveis, e nos jogos eletrônicos.<sup>1</sup></p>

                <p class="resposta">O ramo dos jogos eletrôncios é um dos maiores usufruidores dos avanços gráficos e de maior aplicação de recursos da computação gráfica. O avanço da CG ao lado do avanço do hardware disponível torna os gráficos destes jogos cada vez mais reais.<sup>2</sup></p>
                
                <p class="resposta">A área Computação Gráfica é vasta, e segue avançando em diversas direções. No campo específico dos jogos digitais, a evolução da CG permite imagens cada vez mais fidedignas, que muitas vezes são levadas ao limite do hardware pelos desenvolvedores, que muitas vezes buscam imagens fotorrealisticas que ajudam a atingir a visão artística do projeto.<sup>2</sup></p>

                <p class="resposta">Para Computação Gráfica escolhi falar sobre a subárea de jogos eletrônicos, pois é uma área que gosto muito, e gosto de acompanhar a evolução gráfica de jogos e pesquisando (mesmo que superficialmente) as técnicas utlizadas pelos desenvolvedores.</p>

                <h3>Processamento de Imagens</h3>

                <p class="resposta">No processamento de imagens (PI) as imagens são examindadas e manipuladas por pessoas. Poranto, suas aplicações envolvem pessoas no ciclo, e é necessário entender como funciona o sistema visual humano. Algumas aplicações desta área são: restauração, realce, e compressão.<sup>3</sup></p>
                
                <p class="resposta">A restauração de imagens é o processo de recuperação da aparência original de uma imagem que possui algum grau conhecido (ou estimado) de degradação.<sup>3</sup> Tal degradação ocorre, pois as imagens podem ser corrompidas por ruído, pela função de degradação, ou por ambas. Para restaurar a imagem é necessário aplicar um filtro de restauração.<sup>4</sup></p>
                
                <p class="resposta">A restauração de imagens é de extrema importância, visto que a fotografia pode ser um instrumento de memória e conservação de dados e fatos históricos. Portanto, a restauração destes documentos permite a preservação de fragmentos do passado.<sup>5</sup></p>
                
                <p class="resposta">Escolhi abordar a restauração de imagens, pois foi a aplicação mais intessante para mim no contexto de processamento de imagens.</p>

                <h3>Visão Computacional</h3>

                <p class="resposta">Em aplicações de visão computacional (VC) as imagens processadas (saídas) são usadas pelo computador, ou seja, não necessita de pessoas no seu ciclo visual. As imagens são examinadas, manipuladas, e "interpretadas" pelo computador. A VC resultou de desenvolvimentos nas áreas de biologia e exatas atuando em conjunto. Suas aplicações incluem detecção automática de tumores, sistemas de auxílio a neuro-cirurgias, identificação de impressões digitais, e identificação de impressão DNA (DNA fingertips)<sup>3</sup></p>
                
                <p class="resposta">Atravez de tecnologias como o Deep Learning, a visão computacional consegue identificar variações biológicas e forncer diagnósticos, coisa que só era possível utilizando a visão humana. A vantagem é que a visão computacional é muito mais precisa e capaz de identificar fatores que geralmente passam despercebidos quando não são empregadas soluções tecnológicas.<sup>6</sup></p>
                
                <p class="resposta">A visão computacional, sendo auxiliada por outras tecnologias, é capaz de realizar trabalhos que antes eram feitos apenas por huamanos, mas de forma mais precisa. Problemas como analises de imagens médicas podem ser combatidos com auxílio desta área da computação visual</p>
                
                <p class="resposta">Escolhi abordar a análise de imagens médicas, pois é uma área de extrema importância para a sociedade, e foi a aplicação mais intessante para mim no contexto de Visão Computacional.</p>



            <h3>Referências</h3>
            <ol>
                <li>Artigo "Introdução à Computação Gráfica" - <a href="https://www.inf.pucrs.br/manssour/Publicacoes/TutorialSib2006.pdf" target="_blank">https://www.inf.pucrs.br/manssour/Publicacoes/TutorialSib2006.pdf</a></li>
                <li>Página "Computação Gráfica e Jogos Digitais" - <a href="https://medium.com/@bitsgrupo/computa%C3%A7%C3%A3o-gr%C3%A1fica-e-jogos-digitais-1e15f0febf7c" target="_blank">https://medium.com/@bitsgrupo/computa%C3%A7%C3%A3o-gr%C3%A1fica-e-jogos-digitais-1e15f0febf7c</a></li>
                <li>Slides da USP "Processamento de Imagens" - <a href="https://edisciplinas.usp.br/mod/resource/view.php?id=414515" target="_blank">https://edisciplinas.usp.br/mod/resource/view.php?id=414515</a></li>
                <li>Slides da USP "Processamento Digital de Imagens Médicas" - <a href="https://edisciplinas.usp.br/mod/resource/view.php?id=2507909" target="_blank">https://edisciplinas.usp.br/mod/resource/view.php?id=2507909</a></li>
                <li>Artigo "A importância da conservação fotográfica na reconstrução da memória" - <a href="https://www.metodista.br/revistas/revistas-cogeime/index.php/COGEIME/article/viewFile/579/525" target="_blank">https://www.metodista.br/revistas/revistas-cogeime/index.php/COGEIME/article/viewFile/579/525</a></li>
                <li>Páina do site Aliger - <a href="https://aliger.com.br/como-a-visao-computacional-e-o-deep-learning-estao-sendo-usados-nas-aplicacoes-biologicas/" target="_blank">https://aliger.com.br/como-a-visao-computacional-e-o-deep-learning-estao-sendo-usados-nas-aplicacoes-biologicas/</a></li>
            </ol>
        </section>


        <section id="atvd3">
            <h2 class="tituloAtvd">Atividade 3 (Formatos de imagem)</h2>
            <a href="#indice">Índice de atividades</a>

            <p class="resposta">O formato de imagem/arquivo PNG foi o escolhido, pois sempre gostei deste formato que possui “fundo” transparente ao invés de branco, ou qualquer outra cor. Este formato consiste em uma assinatura de identificação de 8 bytes, seguido por mais três blocos (chunks) de informação. Cada bloco está de acordo com um tipo especificamente definido de estrutura. Tais blocos carregam suas próprias identificações referentes ao seu formato interno, e são lidos de maneira sequencial, do início ao fim do arquivo/fluxo de dados. Por a leitura ser sequencial, não é necessário procurar por diferentes partes do arquivo utilizando valores de deslocamento (offset values). Isso também torna o PNG (e formatos similares) ideal para uso na rede (network) e para protocolos de transmissão de informação. Apesar de ser um formato de arquivo, é mais preciso pensar no PNG como um fluxo de dados que é capturado e armazenado num arquivo.
            </p>

            <p class="resposta">O PNG define 4 blocos padrão, chamados de blocos críticos (critical chunks), que deve ser aceito por todos leitores e escritores de PNG. Estes blocos são:</p>

            <ol>
                <li>The header chunk (IHDR) - Este bloco contém informações básicas sobre os dados da imagem, e deve aparecer como o primeiro bloco, e só pode haver um bloco deste tipo num fluxo de dados PNG.</li>
                <li>The palette chunk (PLTE) - Este bloco armazena os dados do mapa de cores (colormap) associados ao dados da imagem. Só esta presente se a imagem usa uma paleta de cores (color palette), e deve aparecer antes do bloco “image data chunk (IDAT)”.
                </li>
                <li>The image data chunk (IDAT) - Este bloco armazena os dados da imagem em si, e múltiplos blocos deste tipo podem aparecer em um único fluxo de dados, e devem ser armazenados em ordem contígua.
                </li>
                <li>The image trailer chunk (lEND)  - Este bloco deve ser o último, pois marca o fim do arquivo PNG ou o fim do fluxo de dados.
                </li>
            </ol>

            <p class="resposta">Todos esses blocos devem aparecer em todo fluxo de dados de um PNG, exceto o “The palette chunk (PLTE)”.</p>
            <p class="resposta">Blocos opcionais, chamados de blocos acessórios/opcionais (ancillary chunks), podem ser ignorados por leitores de arquivos PNG, e não devem ser escritos por escritores de arquivos PNG. Porém, ao desconsiderar estes blocos opcionais, o leitor PNG pode não conseguir renderizar a imagem de maneira apropriada, fazendo com que a imagem apareça muito clara, ou muito escura, ou de alguma diferente da concepção original. Por isso, é recomendado usar softwares capazes de interpretar blocos opcionais padrões, em especial o bloco relacionado ao gama (Image Gamma chunk).
            </p>
            <p class="resposta">Juntos, os blocos críticos e opcionais são chamados de blocos padrões (standard chunks). Os blocos adicionais são chamados de blocos públicos de propósito especial (special-purpose public chunks), que são implementados em menor quantidade para aplicações específicas. A lista destes blocos públicos de propósito especial tende a crescer com o tempo. Também podem haver blocos privados, para armazenar dados que não precisam ser interpretados por outras aplicações. 
            </p>

            <h3>Referência</h3>
            <p class="resposta">MURRAY, James D.; vanRyper, William. Encyclopedia of Graphics File Formats. Sebastopol: O'Reilly & Associates, 1994.</p>
                
                
        </section>


        <section id="atvd4">
            <h2 class="tituloAtvd">Atividade 4 (GitHub Classroom - AP1)</h2>
            <a href="#indice">Índice de atividades</a>

            <p class="resposta"></p>
        </section>

        <section id="atvd5">
            <h2 class="tituloAtvd">Atividade 5 (GitHub Classroom - AP2)</h2>
            <a href="#indice">Índice de atividades</a>

            <p class="resposta"><a href="https://github.com/profkishimoto-classroom/compvis07g-2024-1-ap2-gkf" target="_blank">Clique aqui para ver no GitHub</a></p>
        </section>

        <section id="atvd6">
            <h2 class="tituloAtvd">Atividade 6 (GitHub Classroom - AP3)</h2>
            <a href="#indice">Índice de atividades</a>

            <p class="resposta"></p>
        </section>

        <section id="atvd7">
            <h2 class="tituloAtvd">Atividade 7 (GitHub Classroom - AP4)</h2>
            <a href="#indice">Índice de atividades</a>

            <p class="resposta"><a href="https://github.com/profkishimoto-classroom/compvis07g-2024-1-ap4-gkf" target="_blank">Clique aqui para ver no GitHub</a></p>
        </section>

        <section id="atvd8">
            <h2 class="tituloAtvd">Atividade 8 (APIs gráficas)</h2>
            <a href="#indice">Índice de atividades</a>

            <p class="resposta">A API OpenGL é definida como "um programa de interface para hardware gráfico". Na verdade, OpenGL é uma biblioteca de rotinas gráficas e de modelagem, bidimensional (2D) e tridimensional (3D), extremamente portável e rápida. Seu uso é semelhante ao de uma biblioteca C, uma vez que fornece uma série de funcionalidades.<sup>1</sup> A maior vantagem desta ferramenta é sua rapidez e sua disponibilidade em sistemas Windows e Linux, pois o concorrente DirectX está presenta apenas no Windows.<sup>2</sup></p>

            <div class="dFlex">
                <div>
                    <p class="resposta">
                        A imagem a direita é o Diagrama do Pipeline de Renderização. As caixas azuis são o estágios de shaders programáveis. O Pipeline de Renderização é iniciado quando a "rendering operation" é realizada/performada. "Rendering operations" exigem a presença de um objeto de matriz de vértices definido corretamente, e um "Program Object" ,ou "Program Pipeline Object", vinculado (linked) que fornece os shaders para os estágios programávies do Pipeline.<sup>3</sup> 
                    </p>
                    <ol>
                        <li>Vertex Processing</li>
                        <ol>
                            <li>Cada "vertex" retirado dos arrays de vertex (conforme definido pelo VAO) é acionado por um(acted upon by a) Vertex Shader. Cada Vertex na stream (fluxo) é processado e se torna um output vertex.</li>
                            <li>Primitiva opcional "tessellation stages"</li>
                            <li>Primitiva opcional de processamento "Geometry Shader". O output é uma sequência de primitivas</li>
                        </ol>
                        <li>"Vertex Post-Processing", os outputs do estágio anterior são ajustados ou transportados para locais diferentes</li>
                        <ol>
                            <li>Transformation Feedback</li>
                            <li>Primitive Assembly</li>
                            <li>"Clipping" primitivo, "perspective divide", "viewport transform to window space"</li>
                        </ol>
                        <li>"Scan Conversion" e "parameter interpolation" primitivo, que gera um número de "Fragments"</li>
                        <li>Um "fragment Shader" processa cada "fragment". Cada "fragment" gera um número de outputs</li>
                        <li>"Per-Sample Operations, incluindo, mas não limitado a:</li>
                        <ol>
                            <li>Scissor Test</li>
                            <li>Stencil Test</li>
                            <li>Depth Test</li>
                            <li>Blending</li>
                            <li>Logical Operation</li>
                            <li>Write Mask</li>
                        </ol>
                    </ol>

                    <p class="resposta">Para mais informações, <a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview" target="_blank">acesse o link</a>.<sup>3</sup></p>
                </div>
                <img src="RenderingPipeline.png" alt="Imagem da Pipeline do OpenGl">
            </div>

            <p class="resposta">Por conta das OpenGL Extensions, existem diversas línguagens de shaders suportadas pela API, sendo a GLSL e a SPIR-V apoiadas diretamente pelo OpenGL sem o uso de extensões. A GLSL (OpenGL Shading Language) é a principal linguagem de shaders para o OpenGL, e é uma linguagem aos moldes de C.<sup>4</sup></p>

            <p>Segue um exemplo de código que renderiza um qudrado na tela. O código foi retirado do <a href="https://www.inf.pucrs.br/~manssour/OpenGL/Tutorial.html" target="_blank">tutorial da PUCRS</a>.<sup>1</sup></p>

            <div class="dFlex">
                <pre>
// Quadrado.c - Isabel H. Manssour
// Um programa OpenGL simples que desenha um 
// quadrado em  uma janela GLUT.
// Este código está baseado no GLRect.c, exemplo 
// disponível no livro "OpenGL SuperBible", 
// 2nd Edition, de Richard S. e Wright Jr.

#include <windows.h>
#include <gl/glut.h>

// Função callback chamada para fazer o desenho
void Desenha(void)
{
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
                   
     // Limpa a janela de visualização com a cor de fundo especificada
     glClear(GL_COLOR_BUFFER_BIT);

     // Especifica que a cor corrente é vermelha
     //         R     G     B
     glColor3f(1.0f, 0.0f, 0.0f);

     // Desenha um quadrado preenchido com a cor corrente
     glBegin(GL_QUADS);
               glVertex2i(100,150);
               glVertex2i(100,100);
               // Especifica que a cor corrente é azul
               glColor3f(0.0f, 0.0f, 1.0f);
               glVertex2i(150,100);
               glVertex2i(150,150);               
     glEnd();

     // Executa os comandos OpenGL
     glFlush();
}

// Inicializa parâmetros de rendering
void Inicializa (void)
{   
    // Define a cor de fundo da janela de visualização como preta
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
}

// Função callback chamada quando o tamanho da janela é alterado 
void AlteraTamanhoJanela(GLsizei w, GLsizei h)
{
    // Evita a divisao por zero
    if(h == 0) h = 1;
            
    // Especifica as dimensões da Viewport
    glViewport(0, 0, w, h);

    // Inicializa o sistema de coordenadas
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    // Estabelece a janela de seleção (left, right, bottom, top)
    if (w <= h) 
            gluOrtho2D (0.0f, 250.0f, 0.0f, 250.0f*h/w);
    else 
            gluOrtho2D (0.0f, 250.0f*w/h, 0.0f, 250.0f);
}

// Programa Principal 
int main(void)
{
     glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
     glutInitWindowSize(400,350);
     glutInitWindowPosition(10,10);
     glutCreateWindow("Quadrado");
     glutDisplayFunc(Desenha);
     glutReshapeFunc(AlteraTamanhoJanela);
     Inicializa();
     glutMainLoop();
}
                </pre>
            

                <img src="quadrado.webp" alt="Quadrado gerado com OpenGL">
            </div>

            <p>Segue trecho de código e output de utilização de GLSL para shaders. O código foi retirado do <a href="https://github.com/ssloy/glsltuto/blob/master/README.md" target="_blank">github</a><sup>5</sup> e tem o processo detalhado no README.</p>

                <pre>
#version 120

uniform vec4 viewport;
attribute float R;

varying mat4 VPMTInverse;
varying mat4 VPInverse;
varying vec3 centernormclip;

void main() {
    gl_Position   = gl_ModelViewProjectionMatrix * gl_Vertex;
    gl_FrontColor = gl_Color;

    mat4 T = mat4(
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            gl_Vertex.x/R, gl_Vertex.y/R, gl_Vertex.z/R, 1.0/R);

    mat4 PMTt = transpose(gl_ModelViewProjectionMatrix * T);

    vec4 r1 = PMTt[0];
    vec4 r2 = PMTt[1];
    vec4 r4 = PMTt[3];
    float r1Dr4T = dot(r1.xyz,r4.xyz)-r1.w*r4.w;
    float r1Dr1T = dot(r1.xyz,r1.xyz)-r1.w*r1.w;
    float r4Dr4T = dot(r4.xyz,r4.xyz)-r4.w*r4.w;
    float r2Dr2T = dot(r2.xyz,r2.xyz)-r2.w*r2.w;
    float r2Dr4T = dot(r2.xyz,r4.xyz)-r2.w*r4.w;

    gl_Position = vec4(-r1Dr4T, -r2Dr4T, gl_Position.z/gl_Position.w*(-r4Dr4T), -r4Dr4T);


    float discriminant_x = r1Dr4T*r1Dr4T-r4Dr4T*r1Dr1T;
    float discriminant_y = r2Dr4T*r2Dr4T-r4Dr4T*r2Dr2T;
    float screen = max(float(viewport.z), float(viewport.w));

    gl_PointSize = sqrt(max(discriminant_x, discriminant_y))*screen/(-r4Dr4T);


    // prepare varyings

    mat4 TInverse = mat4(
            1.0,          0.0,          0.0,         0.0,
            0.0,          1.0,          0.0,         0.0,
            0.0,          0.0,          1.0,         0.0,
            -gl_Vertex.x, -gl_Vertex.y, -gl_Vertex.z, R);
    mat4 VInverse = mat4( // TODO: move this one to CPU
            2.0/float(viewport.z), 0.0, 0.0, 0.0,
            0.0, 2.0/float(viewport.w), 0.0, 0.0,
            0.0, 0.0,                   2.0/gl_DepthRange.diff, 0.0,
            -float(viewport.z+2.0*viewport.x)/float(viewport.z), -float(viewport.w+2.0*viewport.y)/float(viewport.w),
            -(gl_DepthRange.near+gl_DepthRange.far)/gl_DepthRange.diff, 1.0);
    VPMTInverse = TInverse*gl_ModelViewProjectionMatrixInverse*VInverse;
    VPInverse = gl_ProjectionMatrixInverse*VInverse; // TODO: move to CPU
    vec4 centerclip = gl_ModelViewMatrix*gl_Vertex;
    centernormclip = vec3(centerclip)/centerclip.w;
}

                </pre>

                <img src="shader.png" alt="">

                <p class="resposta">As aplicações OpenGL variam de ferramentas CAD a programas de modelagem usados para criar personagens para o cinema, tal como um dinossauro. Além do desenho de primitivas gráficas, tais como linhas e polígonos, OpenGL dá suporte a iluminação, colorização, mapeamento de textura, transparência, animação, entre muitos outros efeitos especiais.<sup>1</sup> Além disso, jogos digitais também utilizam esta API. Segue uma lista de alguns jogos populares que são renderizados com OpenGL: <sup>6</sup></p>
                <ul>
                    <li>Age of Empires III</li>
                    <li>Alien: Isolation</li>
                    <li>Angry Birds</li>
                    <li>Assassin's Creed II</li>
                    <li>Batman: Arkham Asylum</li>
                </ul>

            

            <h3>Referências</h3>
            <ol>
                <li>Tutorial da PUCRS "Introdução à OpenGL" - <a href="https://www.inf.pucrs.br/~manssour/OpenGL/Tutorial.html" target="_blank">https://www.inf.pucrs.br/~manssour/OpenGL/Tutorial.html</a></li>
                <li>Texto do TecMundo "O que é OpenGL?" - <a href="https://www.tecmundo.com.br/video-game/872-o-que-e-opengl-.htm" target="_blank">https://www.tecmundo.com.br/video-game/872-o-que-e-opengl-.htm</a></li>
                <li>Documentação "Rendering Pipeline Overview" - <a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview" target="_blank">https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview</a></li>
                <li>Documentação "OpenGL Shading Language" - <a href="https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language#:~:text=The%20OpenGL%20Shading%20Language%20(GLSL,is%20a%20C%2Dstyle%20language." target="_blank">https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language#:~:text=The%20OpenGL%20Shading%20Language%20(GLSL,is%20a%20C%2Dstyle%20language.</a></li>
                <li>GitHub com código do GLSL (Linguagem do shader) - <a href="https://github.com/ssloy/glsltuto" target="_blank">https://github.com/ssloy/glsltuto</a></li>
                <li>Lista de jogos que usam OpenGL - <a href="https://www.pcgamingwiki.com/wiki/List_of_OpenGL_games" target="_blank">https://www.pcgamingwiki.com/wiki/List_of_OpenGL_games</a></li>
            </ol>
        </section>

    </main>
    
</body>
</html>